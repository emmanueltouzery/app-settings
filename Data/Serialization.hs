{-# OPTIONS_GHC -fno-warn-unused-do-bind #-}
module Data.Serialization (Conf, SettingInfo(..), readConfigFile, writeConfigFile) where

import System.IO
import qualified Data.Text.IO as T
import qualified Data.Map as M
import Text.ParserCombinators.Parsec
import Text.Parsec.Text as T
import Control.Monad (unless)

data SettingInfo = SettingInfo { value :: String, userSet :: Bool } deriving (Show, Eq)

type Conf = M.Map String SettingInfo

-- TODO let the caller know if the file is invalid
readConfigFile :: FilePath -> IO Conf
readConfigFile path = do
	contents <- T.readFile path
	return $ case parse parseConfigFile "" contents of
		Left _ -> M.fromList []
		Right v -> v

data ConfigElement = ConfigEntry String String
	| Comment

isConfigEntry :: ConfigElement -> Bool
isConfigEntry (ConfigEntry _ _) = True
isConfigEntry _ = False

parseConfigFile :: T.GenParser st Conf
parseConfigFile = do
	elements <- many $ parseComment <|> parseConfigEntry
	let configEntries = filter isConfigEntry elements
	return $ M.fromList $ map (\(ConfigEntry a b) ->
		(a, SettingInfo {value=b, userSet=True})) configEntries

parseComment :: T.GenParser st ConfigElement
parseComment = do
	char '#'
	many $ noneOf "\r\n"
	many $ oneOf "\r\n"
	return Comment

parseConfigEntry :: T.GenParser st ConfigElement
parseConfigEntry = do
	key <- many $ noneOf "="
	char '='
	value <- many $ noneOf "\r\n"
	many $ oneOf "\r\n"
	return $ ConfigEntry key value

writeConfigFile :: FilePath -> Conf -> IO ()
writeConfigFile path config = withFile path WriteMode $ \handle -> do
	hPutStrLn handle "# Do not edit, this file is autogenerated"
	mapM_ (uncurry $ writeConfigEntry handle) $ M.toList config

writeConfigEntry :: Handle -> String -> SettingInfo -> IO ()
writeConfigEntry handle key (SettingInfo sValue sUserSet) = do
	unless sUserSet $ hPutStr handle "# "
	hPutStrLn handle $ key ++ "=" ++ sValue
